<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>test</title>
</head>
<body>
<script>
    //原型继承
    function parent(){
        this.a = 100;
        this.b = 200;
        this.func = function(){
            console.log("parent's method");
            console.log(this.a);
        }
    }
    parent.prototype.print = function(){
        console.log("parent console.log");
    }
    function child(){
        this.a = 1000;   //子类中有的a覆盖父类中的a
        this.c = 100;
    }
    child.prototype = new parent();
    child.prototype.constructor = child;
    var p = new parent();
    var c = new child();
    p.print();
    c.print();
    c.func();
    console.log(c);
    //call继承
    function Test(a,b,name) {
        this.a = a;
        this.b = b;
        this.name = name;

        this.print = function() {
            console.log(this.a + " " + this.b+ " "+ this.name);
        }
    }
    Test.prototype.emm = function(){
        console.log("emmmm!");
    }

    function Test02(a,b,name) {
        Test.call(this,a,b,name); //this为当前实例，将父类中的属性和方法变成自己的
    }
    Test02.prototype = new Test();
    Test02.prototype.constructor = Test02;
    var t = new Test02(1,2,"cabbage");
    console.log(t);
    //console.log(t.a);
    //t.print();
    //t.emm();
    //console.log(t instanceof Test02);
    //console.log(t instanceof Test);

    //extends继承
    class A{
        constructor(a){
            this.a = a;
        }
        print(){
            console.log(this.a);
        }
    }
    class B extends A{
        constructor(a,b) {
            super(a);
            this.b = b;
        }
        printB(){
            console.log(this.b);
        }
    }
    var a = new A("a");
    a.print();
    var b = new B("m","b");
    b.print();
    b.printB();
    console.log(b instanceof B);
    console.log(b instanceof A);
</script>
</body>
</html>