<!DOCTYPE <!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>test01</title>
</head>
<body>
    <script>
        /*
         Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。 
         它不同于普通函数，是可以暂停执行的，所以函数名之前要加星号，以示区别。  
         整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。
        */
        function* gen(x){
            var y = yield x + 2;
            return y;
        }
        var g = gen(1);
        //console.log(g);
        //console.log(g.next().value); //{value: 3, done: false}
        //console.log(g.next()); //{value: undefined, done: true}
        //console.log(g);
        /*
        调用 Generator 函数，会返回一个内部指针（即遍历器 ）g 。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会
        返回结果，返回的是指针对象。调用指针 g 的 next 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 yield 
        语句，上例是执行到 x + 2 为止。
        换言之，next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 
        属性和 done 属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 
        函数是否执行完毕，即是否还有下一个阶段。
        */
        console.log(g.next()); //{value: 3, done: false}
        console.log(g.next(2)); //{value: 2, done: true}
        /*
        next 方法返回值的 value 属性，是 Generator 函数向外输出数据；
        next 方法还可以接受参数，这是向 Generator 函数体内输入数据。
        */
    </script>
</body>
</html>